#!/usr/bin/env bash
# mc-git-status - Get git status for a project
# Usage: mc-git-status <project_path> [--json]
# Output: JSON object with counts or tab-separated values

set -uo pipefail

PROJECT_PATH="${1:-.}"
OUTPUT_JSON=false
[[ "${2:-}" == "--json" ]] && OUTPUT_JSON=true

cd "$PROJECT_PATH" 2>/dev/null || { echo '{"error":"invalid path"}'; exit 1; }

# Check if git repo
if [[ ! -d ".git" ]]; then
  if [[ "$OUTPUT_JSON" == true ]]; then
    echo '{"error":"not a git repo"}'
  else
    echo "0	0	0	0	0	"
  fi
  exit 0
fi

# Get branch
branch=$(git branch --show-current 2>/dev/null || echo "detached")

# Get status counts using awk for reliability
porcelain=$(git status --porcelain 2>/dev/null || true)

untracked=0
modified=0
staged=0

if [[ -n "$porcelain" ]]; then
  # Count untracked
  untracked=$(echo "$porcelain" | awk '/^\?\?/ {count++} END {print count+0}')
  # Count modified (workspace)
  modified=$(echo "$porcelain" | awk '/^ [MD]|^[AMD] [MD]/ {count++} END {print count+0}')
  # Count staged
  staged=$(echo "$porcelain" | awk '/^[MADRC]/ {count++} END {print count+0}')
fi

# Get ahead/behind
ahead=0
behind=0
if git rev-parse --abbrev-ref @{u} &>/dev/null; then
  ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
  behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
fi

if [[ "$OUTPUT_JSON" == true ]]; then
  echo "{\"branch\":\"$branch\",\"untracked\":$untracked,\"modified\":$modified,\"staged\":$staged,\"ahead\":$ahead,\"behind\":$behind}"
else
  echo -e "$untracked\t$modified\t$staged\t$ahead\t$behind\t$branch"
fi
